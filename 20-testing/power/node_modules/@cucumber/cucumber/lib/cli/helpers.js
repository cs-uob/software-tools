"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.emitSupportCodeMessages = exports.emitMetaMessage = exports.orderPickles = void 0;
const node_os_1 = __importDefault(require("node:os"));
const knuth_shuffle_seeded_1 = __importDefault(require("knuth-shuffle-seeded"));
const messages = __importStar(require("@cucumber/messages"));
const messages_1 = require("@cucumber/messages");
const ci_environment_1 = __importDefault(require("@cucumber/ci-environment"));
const version_1 = require("../version");
// Orders the pickleIds in place - morphs input
function orderPickles(pickleIds, order, logger) {
    const [type, seed] = splitOrder(order);
    switch (type) {
        case 'defined':
            break;
        case 'random':
            if (seed === '') {
                const newSeed = Math.floor(Math.random() * 1000 * 1000).toString();
                logger.warn(`Random order using seed: ${newSeed}`);
                (0, knuth_shuffle_seeded_1.default)(pickleIds, newSeed);
            }
            else {
                (0, knuth_shuffle_seeded_1.default)(pickleIds, seed);
            }
            break;
        default:
            throw new Error('Unrecognized order type. Should be `defined` or `random`');
    }
}
exports.orderPickles = orderPickles;
function splitOrder(order) {
    if (!order.includes(':')) {
        return [order, ''];
    }
    return order.split(':');
}
async function emitMetaMessage(eventBroadcaster, env) {
    const meta = {
        protocolVersion: messages.version,
        implementation: {
            version: version_1.version,
            name: 'cucumber-js',
        },
        cpu: {
            name: node_os_1.default.arch(),
        },
        os: {
            name: node_os_1.default.platform(),
            version: node_os_1.default.release(),
        },
        runtime: {
            name: 'node.js',
            version: process.versions.node,
        },
        ci: (0, ci_environment_1.default)(env),
    };
    eventBroadcaster.emit('envelope', {
        meta,
    });
}
exports.emitMetaMessage = emitMetaMessage;
const makeSourceReference = (source) => ({
    uri: source.uri,
    location: {
        line: source.line,
    },
});
function emitParameterTypes(supportCodeLibrary, eventBroadcaster, newId) {
    for (const parameterType of supportCodeLibrary.parameterTypeRegistry
        .parameterTypes) {
        if (parameterType.builtin) {
            continue;
        }
        const source = supportCodeLibrary.parameterTypeRegistry.lookupSource(parameterType);
        const envelope = {
            parameterType: {
                id: newId(),
                name: parameterType.name,
                preferForRegularExpressionMatch: parameterType.preferForRegexpMatch,
                regularExpressions: parameterType.regexpStrings,
                useForSnippets: parameterType.useForSnippets,
                sourceReference: makeSourceReference(source),
            },
        };
        eventBroadcaster.emit('envelope', envelope);
    }
}
function emitUndefinedParameterTypes(supportCodeLibrary, eventBroadcaster) {
    for (const undefinedParameterType of supportCodeLibrary.undefinedParameterTypes) {
        const envelope = {
            undefinedParameterType,
        };
        eventBroadcaster.emit('envelope', envelope);
    }
}
function emitStepDefinitions(supportCodeLibrary, eventBroadcaster) {
    supportCodeLibrary.stepDefinitions.forEach((stepDefinition) => {
        const envelope = {
            stepDefinition: {
                id: stepDefinition.id,
                pattern: {
                    source: stepDefinition.pattern.toString(),
                    type: typeof stepDefinition.pattern === 'string'
                        ? messages.StepDefinitionPatternType.CUCUMBER_EXPRESSION
                        : messages.StepDefinitionPatternType.REGULAR_EXPRESSION,
                },
                sourceReference: makeSourceReference(stepDefinition),
            },
        };
        eventBroadcaster.emit('envelope', envelope);
    });
}
function emitTestCaseHooks(supportCodeLibrary, eventBroadcaster) {
    ;
    [
        [
            supportCodeLibrary.beforeTestCaseHookDefinitions,
            messages_1.HookType.BEFORE_TEST_CASE,
        ],
        [
            supportCodeLibrary.afterTestCaseHookDefinitions,
            messages_1.HookType.AFTER_TEST_CASE,
        ],
    ].forEach(([hooks, type]) => {
        hooks.forEach((hook) => {
            eventBroadcaster.emit('envelope', {
                hook: {
                    id: hook.id,
                    type,
                    name: hook.name,
                    tagExpression: hook.tagExpression,
                    sourceReference: makeSourceReference(hook),
                },
            });
        });
    });
}
function emitTestRunHooks(supportCodeLibrary, eventBroadcaster) {
    ;
    [
        [
            supportCodeLibrary.beforeTestRunHookDefinitions,
            messages_1.HookType.BEFORE_TEST_RUN,
        ],
        [
            supportCodeLibrary.afterTestRunHookDefinitions,
            messages_1.HookType.AFTER_TEST_RUN,
        ],
    ].forEach(([hooks, type]) => {
        hooks.forEach((hook) => {
            eventBroadcaster.emit('envelope', {
                hook: {
                    id: hook.id,
                    type,
                    sourceReference: makeSourceReference(hook),
                },
            });
        });
    });
}
function emitSupportCodeMessages({ eventBroadcaster, supportCodeLibrary, newId, }) {
    emitParameterTypes(supportCodeLibrary, eventBroadcaster, newId);
    emitUndefinedParameterTypes(supportCodeLibrary, eventBroadcaster);
    emitStepDefinitions(supportCodeLibrary, eventBroadcaster);
    emitTestCaseHooks(supportCodeLibrary, eventBroadcaster);
    emitTestRunHooks(supportCodeLibrary, eventBroadcaster);
}
exports.emitSupportCodeMessages = emitSupportCodeMessages;
//# sourceMappingURL=helpers.js.map